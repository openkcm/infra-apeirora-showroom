apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: openbao--pre-release
spec:
  interval: 10m
  releaseName: openbao--pre-release
  chart:
    spec:
      chart: ./tools/charts/generic
      sourceRef:
        kind: GitRepository
        name: flux-system
        namespace: flux-system
  install:
    createNamespace: false
    remediation:
      retries: -1
      remediateLastFailure: true
  upgrade:
    remediation:
      retries: -1
      remediateLastFailure: true
  values:
    resources:
      externalsecret-postgres-storage:
        apiVersion: external-secrets.io/v1
        kind: ExternalSecret
        metadata:
          name: openbao-postgres-storage
        spec:
          refreshInterval: 5m
          secretStoreRef:
            name: kubernetes-local-all
            kind: ClusterSecretStore
          target:
            name: openbao-postgres-storage
            creationPolicy: Owner
            template:
              type: Opaque
              engineVersion: v2
              data:
                config.hcl: |-
                  storage "postgresql" {
                    connection_url = "postgres://openbao:{{ .openbao }}@openbao-postgresql.openbao.svc.cluster.local:5432/openbao?sslmode=require"
                  }
          data:
            - secretKey: openbao
              remoteRef:
                key: openbao.openbao-postgresql.credentials.postgresql.acid.zalan.do
                property: password
      issuer-openbao-selfsigned:
        apiVersion: cert-manager.io/v1
        kind: Issuer
        metadata:
          name: openbao-selfsigned
        spec:
          selfSigned: {}
      openbao-server-ca:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          name: openbao-server-ca
        spec:
          isCA: true
          secretName: openbao-server-ca-secret
          commonName: openbao-server-ca
          privateKey:
            algorithm: RSA
            size: 2048
          issuerRef:
            name: openbao-selfsigned
            kind: Issuer
      openbao-server-ca-issuer:
        apiVersion: cert-manager.io/v1
        kind: Issuer
        metadata:
          name: openbao-server-ca-issuer
        spec:
          ca:
            secretName: openbao-server-ca-secret
      certificate-openbao-tls:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          name: openbao-tls
        spec:
          secretName: openbao-tls
          commonName: openbao.openbao.svc
          dnsNames:
            - openbao.openbao.svc
            - openbao.openbao.svc.cluster.local
          issuerRef:
            name: openbao-server-ca-issuer
            kind: Issuer
      injector-selfsigned-ca:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          name: injector-selfsigned-ca
        spec:
          isCA: true
          commonName: Agent Inject CA
          secretName: injector-ca-secret
          duration: 87660h  # 10 years
          privateKey:
            algorithm: ECDSA
            size: 256
          issuerRef:
            name: openbao-selfsigned
            kind: Issuer
            group: cert-manager.io
      injector-ca-issuer:
        apiVersion: cert-manager.io/v1
        kind: Issuer
        metadata:
          name: injector-ca-issuer
        spec:
          ca:
            secretName: injector-ca-secret
      injector-certificate:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          name: injector-certificate
        spec:
          secretName: injector-tls
          duration: 24h
          renewBefore: 144m  # roughly 10% of 24h
          dnsNames:
          - openbao-agent-injector-svc
          - openbao-agent-injector-svc.openbao
          - openbao-agent-injector-svc.openbao.svc
          issuerRef:
            name: injector-ca-issuer
          commonName: Agent Inject Cert
      openbao-client-ca-bootstrap:
        apiVersion: cert-manager.io/v1
        kind: Issuer
        metadata:
          name: openbao-client-ca-bootstrap
        spec:
          selfSigned: {}
      openbao-client-ca:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          name: openbao-client-ca
        spec:
          isCA: true
          secretName: openbao-client-ca-secret
          commonName: openbao-client-ca
          privateKey:
            rotationPolicy: Always
            algorithm: RSA
            size: 2048
          issuerRef:
            name: openbao-client-ca-bootstrap
            kind: Issuer
      openbao-client-issuer:
        apiVersion: cert-manager.io/v1
        kind: Issuer
        metadata:
          name: openbao-client-issuer
        spec:
          ca:
            secretName: openbao-client-ca-secret
      app1-client-certificate:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          name: app1-client
        spec:
          secretName: app1-client-cert
          secretTemplate:
            annotations:
              openbao.cert.auth/policy: app1-policy
          commonName: app1-client
          usages:
            - digital signature
            - key encipherment
            - client auth
          privateKey:
            rotationPolicy: Always
            algorithm: RSA
            size: 2048
          issuerRef:
            name: openbao-client-issuer
            kind: Issuer
      openbao-admin-client-certificate:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          name: openbao-admin
        spec:
          secretName: openbao-admin-cert
          secretTemplate:
            annotations:
              openbao.cert.auth/policy: admin-policy
          commonName: openbao-admin
          usages:
            - digital signature
            - key encipherment
            - client auth
          privateKey:
            rotationPolicy: Always
            algorithm: RSA
            size: 2048
          issuerRef:
            name: openbao-client-issuer
            kind: Issuer
      namespace-admin-client-certificate:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          name: namespace-admin
        spec:
          secretName: namespace-admin-client-cert
          secretTemplate:
            annotations:
              openbao.cert.auth/policy: namespace-admin-policy
          commonName: namespace-admin
          usages:
            - digital signature
            - key encipherment
            - client auth
          privateKey:
            rotationPolicy: Always
            algorithm: RSA
            size: 2048
          issuerRef:
            name: openbao-client-issuer
            kind: Issuer
      key-admin-client-certificate:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          name: key-admin
        spec:
          secretName: key-admin-client-cert
          secretTemplate:
            annotations:
              openbao.cert.auth/policy: key-admin-policy
          commonName: key-admin
          usages:
            - digital signature
            - key encipherment
            - client auth
          privateKey:
            rotationPolicy: Always
            algorithm: RSA
            size: 2048
          issuerRef:
            name: openbao-client-issuer
            kind: Issuer
      openbao-policy-app1:
        apiVersion: v1
        kind: Secret
        metadata:
          name: openbao-policy-app1
        type: Opaque
        stringData:
          app1-policy.hcl: |
            path "kv/data/app1/*" {
              capabilities = ["read", "list"]
            }
      openbao-policy-admin:
        apiVersion: v1
        kind: Secret
        metadata:
          name: openbao-policy-admin
        type: Opaque
        stringData:
          admin-policy.hcl: |
            # Admin policy (explicit paths; refine further later)
            path "auth/token/lookup-self" {
              capabilities = ["read","update"]
            }
            path "auth/token/lookup" {
              capabilities = ["read","update"]
            }
            path "auth/token/renew-self" {
              capabilities = ["read","update"]
            }
            path "auth/token/renew" {
              capabilities = ["read","update"]
            }
            path "auth/token/revoke-self" {
              capabilities = ["read","update"]
            }
            path "sys/policies/acl/*" {
              capabilities = ["create","read","update","delete","list"]
            }
            path "sys/mounts/*" {
              capabilities = ["create","read","update","delete","list","sudo"]
            }
            path "transit/*" {
              capabilities = ["create","read","update","delete","list","sudo"]
            }
            path "secret/*" {
              capabilities = ["create","read","update","delete","list"]
            }
            # JWT auth management
            path "auth/jwt/*" {
              capabilities = ["create","read","update","delete","list","sudo"]
            }
            # Fallback read/list only for everything else
            path "*" {
              capabilities = ["read","list"]
            }
      openbao-policy-namespace-admin:
        apiVersion: v1
        kind: Secret
        metadata:
          name: openbao-policy-namespace-admin
        type: Opaque
        stringData:
          namespace-admin-policy.hcl: |
            # NOTE: Namespace management only works in Enterprise editions. May be ignored in OSS.
            path "sys/namespaces/*" {
              capabilities = ["create","read","update","delete","list"]
            }
            # Allow listing mounts for context
            path "sys/mounts" {
              capabilities = ["read"]
            }
            path "sys/mounts/*" {
              capabilities = ["read","list"]
            }
            # Token self lookup
            path "auth/token/lookup-self" {
              capabilities = ["read"]
            }
            path "auth/token/renew-self" {
              capabilities = ["read","update"]
            }
      openbao-policy-key-admin:
        apiVersion: v1
        kind: Secret
        metadata:
          name: openbao-policy-key-admin
        type: Opaque
        stringData:
          key-admin-policy.hcl: |
            # Manage KV secrets across mounts (v2 common names secret/ and kv/ if present)
            path "secret/*" {
              capabilities = ["create","read","update","delete","list"]
            }
            path "kv/*" {
              capabilities = ["create","read","update","delete","list"]
            }
            # Transit key management
            path "transit/keys/*" {
              capabilities = ["create","read","update","delete","list"]
            }
            path "transit/encrypt/*" {
              capabilities = ["update","read"]
            }
            path "transit/decrypt/*" {
              capabilities = ["update","read"]
            }
            # Token self ops
            path "auth/token/lookup-self" {
              capabilities = ["read"]
            }
            path "auth/token/renew-self" {
              capabilities = ["read","update"]
            }
      openbao-policy-pki-client:
        apiVersion: v1
        kind: Secret
        metadata:
          name: openbao-policy-pki-client
        type: Opaque
        stringData:
          openbao-pki-client.hcl: |
            # Allow signing client certificates via intermediate PKI role (CSR-based)
            path "pki_int/sign/client-cert" {
              capabilities = ["create","update"]
            }
            # Allow signing via root PKI (fallback path)
            path "pki/sign/client-cert" {
              capabilities = ["create","update"]
            }
            path "pki_int/root/sign-intermediate" {
              capabilities = ["create","update"]
            }
            # Read CA chains & CRL
            path "pki/cert/ca" {
              capabilities = ["read","list"]
            }
            path "pki_int/cert/ca" {
              capabilities = ["read","list"]
            }
            path "pki_int/cert/crl" {
              capabilities = ["read","list"]
            }
            # Allow token self introspection
            path "auth/token/lookup-self" {
              capabilities = ["read"]
            }
            path "auth/token/renew-self" {
              capabilities = ["read","update"]
            }
            # (Optional) list mounts for debugging
            path "sys/mounts" {
              capabilities = ["read"]
            }
            path "sys/mounts/*" {
              capabilities = ["read","list"]
            }
      openbao-cert-auth-rbac:
        apiVersion: v1
        kind: List
        metadata:
          name: openbao-cert-auth-rbac-bundle
        items:
          - apiVersion: v1
            kind: ServiceAccount
            metadata:
              name: openbao-cert-auth-sync
          - apiVersion: rbac.authorization.k8s.io/v1
            kind: Role
            metadata:
              name: openbao-cert-auth-sync-secrets
            rules:
              - apiGroups: [""]
                resources: ["secrets"]
                verbs: ["get", "list"]
          - apiVersion: rbac.authorization.k8s.io/v1
            kind: RoleBinding
            metadata:
              name: openbao-cert-auth-sync-secrets
            subjects:
              - kind: ServiceAccount
                name: openbao-cert-auth-sync
            roleRef:
              kind: Role
              name: openbao-cert-auth-sync-secrets
              apiGroup: rbac.authorization.k8s.io
          - apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRole
            metadata:
              name: openbao-cert-auth-sync-clusterissuer
            rules:
              - apiGroups: ["cert-manager.io"]
                resources: ["clusterissuers"]
                verbs: ["get","patch","update"]
          - apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRoleBinding
            metadata:
              name: openbao-cert-auth-sync-clusterissuer
            subjects:
              - kind: ServiceAccount
                name: openbao-cert-auth-sync
                namespace: openbao
            roleRef:
              kind: ClusterRole
              name: openbao-cert-auth-sync-clusterissuer
              apiGroup: rbac.authorization.k8s.io
          - apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRoleBinding
            metadata:
              name: openbao-cert-auth-sync-auth-delegator
            subjects:
              - kind: ServiceAccount
                name: openbao-cert-auth-sync
                namespace: openbao
            roleRef:
              kind: ClusterRole
              name: system:auth-delegator
              apiGroup: rbac.authorization.k8s.io
      openbao-cert-auth-cronjob:
        apiVersion: batch/v1
        kind: CronJob
        metadata:
          name: openbao-cert-auth-sync
        spec:
          schedule: "*/10 * * * *"
          successfulJobsHistoryLimit: 1
          failedJobsHistoryLimit: 3
          jobTemplate:
            spec:
              template:
                spec:
                  serviceAccountName: openbao-cert-auth-sync
                  restartPolicy: Never
                  volumes:
                    - name: root-token
                      secret:
                        secretName: openbao-root
                    - name: tls
                      secret:
                        secretName: openbao-tls
                    - name: admin-client-cert
                      secret:
                        secretName: openbao-admin-cert
                    - name: serviceaccount-token
                      projected:
                        defaultMode: 0444
                        sources:
                          - serviceAccountToken:
                              path: token
                              expirationSeconds: 3600
                          - configMap:
                              name: kube-root-ca.crt
                              items:
                                - key: ca.crt
                                  path: ca.crt
                  containers:
                    - name: sync
                      image: alpine:3.19
                      env:
                        - name: FORCE_MULTI_ISSUER
                          value: "false"
                      volumeMounts:
                        - name: root-token
                          mountPath: /root-token
                          readOnly: true
                        - name: tls
                          mountPath: /tls
                          readOnly: true
                        - name: admin-client-cert
                          mountPath: /admin
                          readOnly: true
                        - name: serviceaccount-token
                          mountPath: /var/run/secrets/kubernetes.io/serviceaccount
                          readOnly: true
                      command: ["sh","-c"]
                      args:
                         - |
                          set -e
                          apk add --no-cache curl jq ca-certificates bash || true
                          # kubectl not in alpine base repos by default; use lightweight client 'kubectl' via curl if absent
                          if ! command -v kubectl >/dev/null 2>&1; then
                            echo "[sync] Installing kubectl (standalone binary)";
                            curl -sL https://dl.k8s.io/release/v1.30.0/bin/linux/amd64/kubectl -o /usr/local/bin/kubectl;
                            chmod +x /usr/local/bin/kubectl;
                          fi
                          command -v kubectl >/dev/null 2>&1 || { echo "[sync] kubectl install failed"; exit 1; }
                          # ------------------------------------------------------------
                          # Install OpenBao CLI (bao) first; fallback to Vault CLI if bao not available
                          # ------------------------------------------------------------
                          if ! command -v bao >/dev/null 2>&1 && ! command -v openbao >/dev/null 2>&1; then
                            echo "[sync] Attempting dynamic OpenBao CLI install";
                            # Target released tag (must match repository tags, e.g. v2.4.3). Use full tag with leading v.
                            OPENBAO_TAG="v2.4.3"
                            # Query GitHub API for assets to avoid guessing archive name.
                            ASSET_JSON=$(curl -s https://api.github.com/repos/openbao/openbao/releases/tags/${OPENBAO_TAG} || true)
                            # Pick first linux_amd64 asset (zip or tar.gz)
                            ASSET_NAME=$(printf '%s' "$ASSET_JSON" | jq -r '.assets[] | .name' | grep -E 'linux_amd64' | head -n1 || true)
                            if [ -n "$ASSET_NAME" ]; then
                              ASSET_URL=$(printf '%s' "$ASSET_JSON" | jq -r --arg n "$ASSET_NAME" '.assets[] | select(.name==$n) | .browser_download_url')
                              echo "[sync] Found OpenBao asset: $ASSET_NAME"
                              curl -sL "$ASSET_URL" -o /tmp/openbao_asset || echo "[sync] Download failed for $ASSET_NAME"
                              if [ -s /tmp/openbao_asset ]; then
                                FILE_TYPE="$(file -b /tmp/openbao_asset || true)"
                                apk add --no-cache unzip tar >/dev/null 2>&1 || true
                                if echo "$ASSET_NAME" | grep -qE '\.zip$'; then
                                  mv /tmp/openbao_asset /tmp/openbao.zip
                                  unzip -o /tmp/openbao.zip -d /usr/local/bin >/dev/null 2>&1 || true
                                elif echo "$ASSET_NAME" | grep -qE '\.(tar\.gz|tgz)$'; then
                                  mv /tmp/openbao_asset /tmp/openbao.tar.gz
                                  tar -xzf /tmp/openbao.tar.gz -C /usr/local/bin >/dev/null 2>&1 || true
                                else
                                  # Assume raw binary
                                  mv /tmp/openbao_asset /usr/local/bin/bao || mv /tmp/openbao_asset /usr/local/bin/openbao || true
                                fi
                                # Try standard binary names to chmod
                                for B in bao openbao vault; do
                                  [ -f "/usr/local/bin/$B" ] && chmod +x "/usr/local/bin/$B" || true
                                done
                              fi
                            else
                              echo "[sync] No matching linux_amd64 asset found for OpenBao tag ${OPENBAO_TAG}";
                            fi
                          fi
                          if command -v bao >/dev/null 2>&1; then echo "[sync] bao CLI installed"; elif command -v openbao >/dev/null 2>&1; then echo "[sync] openbao CLI installed"; else echo "[sync] OpenBao CLI not available (will fallback to vault)"; fi
                          if ! command -v vault >/dev/null 2>&1; then
                            echo "[sync] Installing vault CLI (fallback)";
                            VAULT_VERSION="1.16.2"
                            curl -sL https://releases.hashicorp.com/vault/${VAULT_VERSION}/vault_${VAULT_VERSION}_linux_amd64.zip -o /tmp/vault.zip || { echo "[sync] Failed downloading vault"; }
                            if [ -f /tmp/vault.zip ]; then
                              apk add --no-cache unzip >/dev/null 2>&1 || true
                              unzip -o /tmp/vault.zip -d /usr/local/bin >/dev/null 2>&1 || true
                              chmod +x /usr/local/bin/vault || true
                            fi
                          fi
                          if command -v vault >/dev/null 2>&1; then echo "[sync] vault CLI installed"; fi
                          HOST="https://openbao.openbao.svc:8200"
                          TOKEN=$(cat /root-token/root-token)
                          # Determine CA to trust: prefer /tls/ca.crt if present else /tls/tls.crt (self-signed cert includes its own cert as CA)
                          if [ -f /tls/ca.crt ]; then CA_CERT=/tls/ca.crt; else CA_CERT=/tls/tls.crt; fi
                          CLIENT_CERT=/admin/tls.crt
                          CLIENT_KEY=/admin/tls.key
                          if [ ! -f "$CLIENT_CERT" ] || [ ! -f "$CLIENT_KEY" ]; then echo "[sync] Missing admin client cert/key for mTLS; exiting."; exit 1; fi
                          # Export environment so vault CLI can use mTLS & token automatically.
                          export VAULT_ADDR="$HOST"
                          export VAULT_TOKEN="$TOKEN"
                          # vault CLI does not natively take separate client cert/key env vars; use VAULT_CACERT and set CURL_CA_BUNDLE.
                          export VAULT_CACERT="$CA_CERT"
                          # For mTLS with CLI we wrap via 'vault -ca-cert= -client-cert= -client-key=' flags when needed.
                          VAULT_TLS_ARGS="-ca-cert=$CA_CERT -client-cert=$CLIENT_CERT -client-key=$CLIENT_KEY"
                          # Helper command wrappers preferring bao over vault
                          vault_like() {
                            if command -v bao >/dev/null 2>&1; then
                              bao $VAULT_TLS_ARGS "$@"
                            elif command -v vault >/dev/null 2>&1; then
                              vault $VAULT_TLS_ARGS "$@"
                            else
                              echo "[sync] Neither bao nor vault CLI present; cannot run: $@"; return 1
                            fi
                          }
                          bao_cmd() { vault_like "$@"; }
                          vault_cmd() { vault_like "$@"; }
                          # ---------------------------------------------------------------------------
                          # PKI ROLE NAMING RULES (CN / SAN CONSTRAINTS)
                          # ---------------------------------------------------------------------------
                          # By default we used: {"allow_any_name":true,...} which permits any Common Name.
                          # To enforce naming rules you adjust the role JSON when creating roles:
                          #  * allow_any_name: false -> forces CN/SAN to match allowed_domains list (for DNS-like names)
                          #  * allowed_domains: list of base domains permitted (CN must be a hostname under these if enforce_hostnames=true)
                          #  * allow_subdomains: true to allow sub.example.com if example.com listed
                          #  * allow_glob_domains: true allows patterns like *.svc.cluster.local
                          #  * allowed_uri_sans: restrict URIs (e.g. SPIFFE IDs)
                          #  * allowed_other_sans: constrain arbitrary OIDs (format: "OID:VALUE")
                          #  * require_cn: true ensures CN present in CSR
                          #  * enforce_hostnames: true validates CN is also in SANs (and is a valid hostname)
                          #  * allowed_organizational_units / organization / country / province / locality etc can pin subject attributes.
                          # NOTE: Your current Certificates use CN values like 'app1-client' which are NOT DNS names.
                          # If you switch to restrictive domain-based rules, change CN to something like 'app1.openbao.internal'.
                          # Example STRICT role definition (disabled by default):
                          # ROLE_CONSTRAINTS='{"allow_any_name":false,"allowed_domains":["openbao.internal"],"allow_subdomains":true,"allow_glob_domains":false,"allow_bare_domains":false,"require_cn":true,"enforce_hostnames":false,"key_type":"rsa","key_bits":2048,"max_ttl":"720h","ttl":"24h","generate_lease":true}'
                          # For now we keep permissive role to avoid breaking existing CNs. To activate strict rules:
                          # 1) Uncomment ROLE_CONSTRAINTS above
                          # 2) Replace usage below: -d "$ROLE_CONSTRAINTS" instead of inline JSON
                          # 3) Update Certificate specs to use DNS-acceptable CN or rely solely on SANs.
                          # ---------------------------------------------------------------------------
                          echo "[sync] Waiting for unseal..."
                          until curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s $HOST/v1/sys/seal-status | grep '"sealed":false' >/dev/null; do sleep 3; done
                          echo "[sync] Ensure cert auth enabled..."
                          if ! curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/sys/auth | jq -e 'has("cert/")' >/dev/null 2>&1; then
                          curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/sys/auth/cert -d '{"type":"cert"}'
                          echo "[sync] Enabled cert auth";
                          fi
                          echo "[sync] Ensure jwt auth enabled..."
                          if ! curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/sys/auth | jq -e 'has("jwt/")' >/dev/null 2>&1; then
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/sys/auth/jwt -d '{"type":"jwt"}' && echo "[sync] Enabled jwt auth" || echo "[sync] Failed to enable jwt auth";
                          fi
                          JWT_ISSUER="https://discovery.ingress.garden.gardener.cc-one.showroom.apeirora.eu/projects/kms/shoots/53ec7160-dfe7-47b0-9d96-75daa9c7a687/issuer"
                          echo "[sync] Configuring jwt auth (issuer=$JWT_ISSUER)..."
                          curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/auth/jwt/config -d '{"oidc_discovery_url":"'$JWT_ISSUER'","default_role":"jwt-admin","bound_issuer":"'$JWT_ISSUER'"}' >/dev/null || echo "[sync] jwt config failed (may already exist)"
                          echo "[sync] Ensuring jwt-admin role exists..."
                          if ! curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/auth/jwt/role/jwt-admin | jq -e '.data' >/dev/null 2>&1; then
                            echo "[sync] jwt-admin role not found; creating (role_type=jwt)"
                            # Using role_type=jwt to avoid OIDC redirect requirements since we only validate bearer tokens.
                            RESP=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -w '\n%{http_code}' -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/auth/jwt/role/jwt-admin -d '{"role_type":"jwt","user_claim":"sub","bound_audiences":["vault","openbao","api"],"policies":["admin-policy"],"token_ttl":"1h","token_max_ttl":"2h"}')
                            BODY=$(printf "%s" "$RESP" | sed '$d')
                            CODE=$(printf "%s" "$RESP" | tail -n1)
                            if [ "$CODE" != "200" ] && [ "$CODE" != "204" ]; then
                              echo "[sync] Failed to create jwt-admin role (HTTP $CODE): $BODY"; else echo "[sync] jwt-admin role created"; fi
                          else
                            echo "[sync] jwt-admin role already present"
                          fi
                          echo "[sync] Syncing policy secrets into Vault..."
                          for PSEC in $(kubectl -n openbao get secrets -o json | jq -r '.items[] | select(.metadata.name | startswith("openbao-policy-")) | .metadata.name'); do
                            for KEY in $(kubectl -n openbao get secret "$PSEC" -o json | jq -r '.data | keys[]'); do
                              PNAME=$(echo "$KEY" | sed 's/.hcl$//')
                              PCONTENT=$(kubectl -n openbao get secret "$PSEC" -o json | jq -r --arg k "$KEY" '.data[$k]' | base64 -d)
                              if [ -z "$PCONTENT" ]; then echo "[sync] Empty policy content for $PNAME in $PSEC; skipping"; continue; fi
                              echo "[sync] Upserting policy $PNAME"
                              curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X PUT $HOST/v1/sys/policies/acl/$PNAME -d "{\"policy\":$(printf '%s' "$PCONTENT" | jq -Rs .)}" >/dev/null || echo "[sync] Failed to upsert policy $PNAME"
                            done
                          done
                          echo "[sync] Ensuring transit mount..."
                          if ! curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/sys/mounts | jq -e 'has("transit/")' >/dev/null 2>&1; then
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/sys/mounts/transit -d '{"type":"transit"}' && echo "[sync] Mounted transit" || echo "[sync] Failed to mount transit"
                          fi
                          echo "[sync] Ensuring kubernetes auth enabled..."
                          if ! curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/sys/auth | jq -e 'has("kubernetes/")' >/dev/null 2>&1; then
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/sys/auth/kubernetes -d '{"type":"kubernetes"}' && echo "[sync] Enabled kubernetes auth" || echo "[sync] Failed to enable kubernetes auth"
                          fi
                          echo "[sync] Configuring kubernetes auth..."
                          SA_JWT=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token || true)
                          KUBE_CA=$(cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt || true)
                          if [ -n "$SA_JWT" ] && [ -n "$KUBE_CA" ]; then
                            PAYLOAD=$(jq -n --arg jwt "$SA_JWT" --arg ca "$KUBE_CA" '{token_reviewer_jwt:$jwt, kubernetes_host:"https://kubernetes.default.svc:443", kubernetes_ca_cert:$ca, issuer:"https://kubernetes.default.svc.cluster.local"}')
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/auth/kubernetes/config -d "$PAYLOAD" >/dev/null || echo "[sync] kubernetes auth config failed (may already exist)"
                            echo "[sync] Testing kubernetes login for cert-manager role..."
                            LOGIN_RESP=$(curl --cacert $CA_CERT -s -w '\n%{http_code}' -X POST $HOST/v1/auth/kubernetes/login -d '{"role":"cert-manager-pki","jwt":"'$SA_JWT'"}')
                            LOGIN_BODY=$(printf '%s' "$LOGIN_RESP" | sed '$d')
                            LOGIN_CODE=$(printf '%s' "$LOGIN_RESP" | tail -n1)
                            if [ "$LOGIN_CODE" != "200" ]; then
                              echo "[sync] Kubernetes login test failed (HTTP $LOGIN_CODE)"; echo "$LOGIN_BODY" | jq '.errors? // empty' || true
                            else
                              echo "[sync] Kubernetes login test succeeded"
                            fi
                          else
                            echo "[sync] Missing SA JWT or CA for kubernetes auth config; skipping"
                          fi
                          echo "[sync] Ensuring kubernetes role cert-manager-pki..."
                          if ! curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/auth/kubernetes/role/cert-manager-pki | jq -e '.data' >/dev/null 2>&1; then
                            RESP=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -w '\n%{http_code}' -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/auth/kubernetes/role/cert-manager-pki -d '{"bound_service_account_names":["cert-manager","openbao-cert-auth-sync"],"bound_service_account_namespaces":["cert-manager","openbao"],"policies":["openbao-pki-client"],"token_ttl":"1h","token_max_ttl":"4h"}')
                            BODY=$(printf "%s" "$RESP" | sed '$d')
                            CODE=$(printf "%s" "$RESP" | tail -n1)
                            if [ "$CODE" != "200" ] && [ "$CODE" != "204" ]; then
                              echo "[sync] Failed to create kubernetes role cert-manager-pki (HTTP $CODE): $BODY"; else echo "[sync] Created kubernetes role cert-manager-pki"; fi
                          else
                            echo "[sync] kubernetes role cert-manager-pki already present"
                            ROLE_JSON=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/auth/kubernetes/role/cert-manager-pki || true)
                            if ! echo "$ROLE_JSON" | jq -e '.data.bound_service_account_names[] | select(.=="openbao-cert-auth-sync")' >/dev/null 2>&1; then
                              echo "[sync] Patching role to include openbao-cert-auth-sync"
                              PATCH=$(jq -n '{bound_service_account_names:["cert-manager","openbao-cert-auth-sync"],bound_service_account_namespaces:["cert-manager","openbao"],policies:["openbao-pki-client"],token_ttl:"1h",token_max_ttl:"4h"}')
                              curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/auth/kubernetes/role/cert-manager-pki -d "$PATCH" >/dev/null || echo "[sync] Failed to patch kubernetes role cert-manager-pki"
                            fi
                          fi
                          echo "[sync] Ensuring PKI mounts..."
                          CURRENT_MOUNTS=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/sys/mounts)
                          if ! echo "$CURRENT_MOUNTS" | jq -e 'has("pki/")' >/dev/null 2>&1; then
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/sys/mounts/pki -d '{"type":"pki","config":{"max_lease_ttl":"87600h"}}' && echo "[sync] Mounted pki" || echo "[sync] Failed to mount pki"
                          fi
                          if ! echo "$CURRENT_MOUNTS" | jq -e 'has("pki_int/")' >/dev/null 2>&1; then
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/sys/mounts/pki_int -d '{"type":"pki","config":{"max_lease_ttl":"43800h"}}' && echo "[sync] Mounted pki_int" || echo "[sync] Failed to mount pki_int"
                          fi
                          echo "[sync] Ensuring root CA generated..."
                          if ! curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/pki/cert/ca | jq -e '.data.certificate' >/dev/null 2>&1; then
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki/root/generate/internal -d '{"common_name":"openbao-root-ca","ttl":"87600h"}' >/dev/null && echo "[sync] Generated root CA" || echo "[sync] Failed to generate root CA"
                            # Configure URLs (best-effort)
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki/config/urls -d '{"issuing_certificates":"'$HOST'/v1/pki/ca","crl_distribution_points":"'$HOST'/v1/pki/crl"}' >/dev/null || true
                          fi
                          echo "[sync] Ensuring intermediate signed..."
                          if ! curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/pki_int/cert/ca | jq -e '.data.certificate' >/dev/null 2>&1; then
                            echo "[sync] Generating intermediate CSR (ttl=43800h)";
                            CSR=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki_int/intermediate/generate/internal -d '{"common_name":"openbao-intermediate","ttl":"43800h"}' | jq -r '.data.csr')
                            if [ -z "$CSR" ]; then
                              echo "[sync] Failed to generate intermediate CSR";
                            else
                              CSR_JSON=$(printf '%s' "$CSR" | jq -Rs .)
                                # Multi-issuer preferred. If FORCE_MULTI_ISSUER=true then error on absence; else fallback to legacy root sign.
                                ROOT_ISSUERS_CODE=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -o /dev/null -w '%{http_code}' -H "X-Vault-Token: $TOKEN" $HOST/v1/pki/issuers || true)
                                if [ "$ROOT_ISSUERS_CODE" = "200" ]; then
                                  ROOT_ISSUERS_JSON=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/pki/issuers || true)
                                  PRIMARY_ISSUER=$(echo "$ROOT_ISSUERS_JSON" | jq -r '.data.issuer_ids[0] // empty')
                                  if [ -n "$PRIMARY_ISSUER" ]; then
                                    echo "[sync] Using root issuer $PRIMARY_ISSUER (multi-issuer) to sign intermediate"
                                    SIGNED=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki/issuer/$PRIMARY_ISSUER/sign-intermediate -d '{"csr":'$CSR_JSON',"format":"pem","ttl":"43800h"}' | jq -r '.data.certificate' || true)
                                    # Attempt to set default issuer (best-effort)
                                    curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki/issuer/$PRIMARY_ISSUER/set-default >/dev/null || true
                                  else
                                    if [ "${FORCE_MULTI_ISSUER}" = "true" ]; then
                                      echo "[sync] ERROR: Multi-issuer endpoint returned no issuer_ids and FORCE_MULTI_ISSUER=true"; exit 1;
                                    else
                                      echo "[sync] WARNING: Multi-issuer endpoint returned no issuer_ids; falling back to legacy root sign-intermediate"
                                    fi
                                  fi
                                else
                                  if [ "${FORCE_MULTI_ISSUER}" = "true" ]; then
                                    echo "[sync] ERROR: Multi-issuer endpoint unavailable (HTTP $ROOT_ISSUERS_CODE) with FORCE_MULTI_ISSUER=true"; exit 1;
                                  else
                                    echo "[sync] Multi-issuer unsupported (HTTP $ROOT_ISSUERS_CODE); using legacy root sign-intermediate"
                                  fi
                                fi
                                if [ -z "$SIGNED" ]; then
                                  # Legacy fallback if not signed yet
                                  if [ "${FORCE_MULTI_ISSUER}" != "true" ]; then
                                    SIGNED=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki/root/sign-intermediate -d '{"csr":'$CSR_JSON',"format":"pem","ttl":"43800h"}' | jq -r '.data.certificate' || true)
                                  fi
                                fi
                                if [ -n "$SIGNED" ]; then
                                  SIGNED_JSON=$(printf '%s' "$SIGNED" | jq -Rs .)
                                  curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki_int/intermediate/set-signed -d '{"certificate":'$SIGNED_JSON'}' >/dev/null && echo "[sync] Set signed intermediate" || echo "[sync] Failed to set signed intermediate"
                                else
                                  echo "[sync] ERROR: Failed to obtain signed intermediate certificate (multi-issuer + fallback paths)"; exit 1;
                                fi
                            fi
                          fi
                          echo "[sync] Configuring intermediate issuing & default issuer..."
                          # Multi-issuer simplified handling
                          CI_PATH=$(kubectl get clusterissuer openbao-pki -o jsonpath='{.spec.vault.path}' 2>/dev/null || true)
                          ISSUERS_CODE=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -o /dev/null -w '%{http_code}' -H "X-Vault-Token: $TOKEN" $HOST/v1/pki_int/issuers || true)
                          if [ "$ISSUERS_CODE" != "200" ]; then
                            echo "[sync] Multi-issuer unsupported (HTTP $ISSUERS_CODE); ensure ClusterIssuer uses intermediate sign path"
                            if [ "$CI_PATH" != "pki_int/sign/client-cert" ]; then
                              PATCH=$(jq -n '{spec:{vault:{path:"pki_int/sign/client-cert"}}}')
                              kubectl patch clusterissuer openbao-pki --type=merge -p "$PATCH" || echo "[sync] Failed to patch ClusterIssuer back to intermediate sign path"
                            fi
                          else
                            echo "[sync] Multi-issuer supported; setting intermediate URLs (no import attempts)"
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki_int/config/urls -d '{"issuing_certificates":"'$HOST'/v1/pki_int/ca","crl_distribution_points":"'$HOST'/v1/pki_int/crl"}' >/dev/null || echo "[sync] Failed to set pki_int URLs"
                          fi
                          echo "[sync] Ensuring PKI role client-cert..."
                          if ! curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/pki_int/roles/client-cert | jq -e '.data' >/dev/null 2>&1; then
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki_int/roles/client-cert -d '{"allow_any_name":true,"key_type":"rsa","key_bits":2048,"max_ttl":"720h","ttl":"24h","generate_lease":true,"use_csr_values":true,"use_csr_common_name":true,"require_cn":false,"allowed_organizational_units":["9d3f2b4e-5c1a-4d4e-ae6d-6c4d6a7f9b23","PlatformMesh"],"organization":["ApeiroRA"],"country":["DE"]}' >/dev/null && echo "[sync] Created PKI role client-cert (permissive + CSR + subject constraints)" || echo "[sync] Failed to create PKI role client-cert"
                          else
                            # Attempt to patch existing role with CSR flags and subject constraints
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki_int/roles/client-cert -d '{"allow_any_name":true,"key_type":"rsa","key_bits":2048,"max_ttl":"720h","ttl":"24h","generate_lease":true,"use_csr_values":true,"use_csr_common_name":true,"require_cn":false,"allowed_organizational_units":["9d3f2b4e-5c1a-4d4e-ae6d-6c4d6a7f9b23","PlatformMesh"],"organization":["ApeiroRA"],"country":["DE"]}' >/dev/null && echo "[sync] Ensured PKI role client-cert updated with CSR + subject constraints" || echo "[sync] Failed to update PKI role client-cert"
                          fi
                          # Verify role contains allowed_organizational_units; retry with minimal payload if missing
                          ROLE_JSON=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/pki_int/roles/client-cert || true)
                          if ! echo "$ROLE_JSON" | jq -e '.data.allowed_organizational_units | index("PlatformMesh")' >/dev/null 2>&1; then
                            echo "[sync] allowed_organizational_units not present after update; retrying with simplified role definition"
                            SIMPLIFIED='{"allow_any_name":true,"key_type":"rsa","key_bits":2048,"max_ttl":"720h","ttl":"24h","generate_lease":true,"use_csr_values":true,"use_csr_common_name":true,"require_cn":false,"allowed_organizational_units":["9d3f2b4e-5c1a-4d4e-ae6d-6c4d6a7f9b23","PlatformMesh"]}'
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki_int/roles/client-cert -d "$SIMPLIFIED" >/dev/null && echo "[sync] Retried PKI role with simplified payload" || echo "[sync] Retry failed for PKI role"
                            ROLE_JSON=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/pki_int/roles/client-cert || true)
                            if echo "$ROLE_JSON" | jq -e '.data.allowed_organizational_units | index("PlatformMesh")' >/dev/null 2>&1; then
                              echo "[sync] allowed_organizational_units now present"
                            else
                              echo "[sync] WARNING: allowed_organizational_units still missing; OpenBao/Vault build may not support this field"
                            fi
                          fi
                          # If ClusterIssuer currently points to root fallback path ensure root role mirrors settings
                          ROOT_CI_PATH=$(kubectl get clusterissuer openbao-pki -o jsonpath='{.spec.vault.path}' 2>/dev/null || true)
                          if [ "$ROOT_CI_PATH" = "pki/sign/client-cert" ]; then
                            echo "[sync] Ensuring root PKI role client-cert (fallback path) ..."
                            if ! curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/pki/roles/client-cert | jq -e '.data' >/dev/null 2>&1; then
                              curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki/roles/client-cert -d '{"allow_any_name":true,"key_type":"rsa","key_bits":2048,"max_ttl":"720h","ttl":"24h","generate_lease":true,"use_csr_values":true,"use_csr_common_name":true,"require_cn":false,"allowed_organizational_units":["9d3f2b4e-5c1a-4d4e-ae6d-6c4d6a7f9b23","PlatformMesh"],"organization":["ApeiroRA"],"country":["DE"]}' >/dev/null && echo "[sync] Created root PKI role client-cert (with subject constraints)" || echo "[sync] Failed to create root PKI role client-cert"
                            else
                              curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki/roles/client-cert -d '{"allow_any_name":true,"key_type":"rsa","key_bits":2048,"max_ttl":"720h","ttl":"24h","generate_lease":true,"use_csr_values":true,"use_csr_common_name":true,"require_cn":false,"allowed_organizational_units":["9d3f2b4e-5c1a-4d4e-ae6d-6c4d6a7f9b23","PlatformMesh"],"organization":["ApeiroRA"],"country":["DE"]}' >/dev/null && echo "[sync] Ensured root PKI role client-cert updated with subject constraints" || echo "[sync] Failed to update root PKI role client-cert"
                            fi
                            ROOT_ROLE_JSON=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/pki/roles/client-cert || true)
                            if ! echo "$ROOT_ROLE_JSON" | jq -e '.data.allowed_organizational_units | index("PlatformMesh")' >/dev/null 2>&1; then
                              echo "[sync] Root role missing allowed_organizational_units; retrying simplified root role payload"
                              SIMPLIFIED_ROOT='{"allow_any_name":true,"key_type":"rsa","key_bits":2048,"max_ttl":"720h","ttl":"24h","generate_lease":true,"use_csr_values":true,"use_csr_common_name":true,"require_cn":false,"allowed_organizational_units":["9d3f2b4e-5c1a-4d4e-ae6d-6c4d6a7f9b23","PlatformMesh"]}'
                              curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki/roles/client-cert -d "$SIMPLIFIED_ROOT" >/dev/null && echo "[sync] Retried root PKI role simplified" || echo "[sync] Root PKI role simplified retry failed"
                              ROOT_ROLE_JSON=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/pki/roles/client-cert || true)
                              if echo "$ROOT_ROLE_JSON" | jq -e '.data.allowed_organizational_units | index("PlatformMesh")' >/dev/null 2>&1; then
                                echo "[sync] Root allowed_organizational_units now present"
                              else
                                echo "[sync] WARNING: Root allowed_organizational_units still missing; OpenBao/Vault build may not support this field"
                              fi
                            fi
                          fi
                            echo "[sync] Dynamic caBundle sync (openbao-tls secret tls.crt -> base64)"
                            # Field spec.vault.caBundle expects bytes; we must patch with base64 (raw JSON string containing base64 data)
                            CERT_PEM=$(kubectl -n openbao get secret openbao-tls -o jsonpath='{.data.tls\.crt}' 2>/dev/null | base64 -d || true)
                            if echo "$CERT_PEM" | grep -q "BEGIN CERTIFICATE"; then
                              CA_B64=$(printf '%s' "$CERT_PEM" | base64 -w0)
                            else
                              # Secret may already store base64 of DER; use raw if no PEM markers
                              CA_B64=$(kubectl -n openbao get secret openbao-tls -o jsonpath='{.data.tls\.crt}' 2>/dev/null || true)
                            fi
                            if [ -n "$CA_B64" ]; then
                              CURRENT=$(kubectl get clusterissuer openbao-pki -o jsonpath='{.spec.vault.caBundle}' 2>/dev/null || true)
                              if [ "$CURRENT" != "$CA_B64" ]; then
                                echo "[sync] Patching ClusterIssuer caBundle (base64)"
                                PATCH=$(jq -n --arg cb "$CA_B64" '{spec:{vault:{caBundle:$cb}}}')
                                kubectl patch clusterissuer openbao-pki --type=merge -p "$PATCH" || echo "[sync] Failed to patch caBundle"
                              else
                                echo "[sync] ClusterIssuer caBundle already up to date"
                              fi
                            else
                              echo "[sync] Could not construct base64 caBundle from secret openbao-tls"
                            fi
                          echo "[sync] Processing annotated secrets..."
                          for S in $(kubectl -n openbao get secrets -o json | jq -r '.items[] | select(.metadata.annotations["openbao.cert.auth/policy"]) | .metadata.name'); do
                          POLICY=$(kubectl -n openbao get secret "$S" -o jsonpath='{.metadata.annotations.openbao\.cert\.auth/policy}')
                          echo "[sync] Found annotated secret $S (policies=$POLICY)"
                          CERT_PEM=$(kubectl -n openbao get secret "$S" -o jsonpath='{.data.tls\.crt}' | base64 -d || true)
                          if [ -z "$CERT_PEM" ]; then echo "[sync] Empty certificate data in $S; skipping"; continue; fi
                          echo "[sync] Mapping $S -> $POLICY"
                          PAYLOAD=$(printf '%s' "$CERT_PEM" | jq -Rs --arg policies "$POLICY" '{certificate: ., policies: $policies, ttl: "1h"}')
                          curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST "$HOST/v1/auth/cert/certs/$S" -d "$PAYLOAD" >/dev/null
                          curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/auth/cert/certs/$S | jq '.policies' >/dev/null || { echo "[sync] Verification failed for $S"; exit 1; }
                          done
                          echo "[sync] Done."
      openbao-cluster-issuer:
        apiVersion: cert-manager.io/v1
        kind: ClusterIssuer
        metadata:
          name: openbao-pki
          annotations:
            openbao.io/managed: "helm"
        spec:
          vault:
            server: https://openbao.openbao.svc:8200
            # Use sign endpoint to avoid Vault generating its own key (lib vault 'issue' path produces a cert + key mismatch in our mTLS issuance context)
            path: pki_int/root/sign-intermediate
            auth:
              kubernetes:
                mountPath: /v1/auth/kubernetes
                role: cert-manager-pki
                serviceAccountRef:
                  name: cert-manager
            # caBundle omitted here; CronJob dynamically patches spec.vault.caBundle using base64 of tls.crt from secret openbao-tls.
