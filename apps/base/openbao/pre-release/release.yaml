apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: openbao--pre-release
spec:
  interval: 10m
  releaseName: openbao--pre-release
  chart:
    spec:
      chart: ./tools/charts/generic
      sourceRef:
        kind: GitRepository
        name: flux-system
        namespace: flux-system
  install:
    createNamespace: false
    remediation:
      retries: -1
      remediateLastFailure: true
  upgrade:
    remediation:
      retries: -1
      remediateLastFailure: true
  values:
    resources:
      externalsecret-postgres-storage:
        apiVersion: external-secrets.io/v1
        kind: ExternalSecret
        metadata:
          name: openbao-postgres-storage
        spec:
          refreshInterval: 5m
          secretStoreRef:
            name: kubernetes-local-all
            kind: ClusterSecretStore
          target:
            name: openbao-postgres-storage
            creationPolicy: Owner
            template:
              type: Opaque
              engineVersion: v2
              data:
                config.hcl: |-
                  storage "postgresql" {
                    connection_url = "postgres://openbao:{{ .openbao }}@openbao-postgresql.openbao.svc.cluster.local:5432/openbao?sslmode=require"
                  }
          data:
            - secretKey: openbao
              remoteRef:
                key: openbao.openbao-postgresql.credentials.postgresql.acid.zalan.do
                property: password
      issuer-openbao-selfsigned:
        apiVersion: cert-manager.io/v1
        kind: Issuer
        metadata:
          name: openbao-selfsigned
        spec:
          selfSigned: {}
      openbao-server-ca:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          name: openbao-server-ca
        spec:
          isCA: true
          secretName: openbao-server-ca-secret
          commonName: openbao-server-ca
          privateKey:
            algorithm: RSA
            size: 2048
          issuerRef:
            name: openbao-selfsigned
            kind: Issuer
      openbao-server-ca-issuer:
        apiVersion: cert-manager.io/v1
        kind: Issuer
        metadata:
          name: openbao-server-ca-issuer
        spec:
          ca:
            secretName: openbao-server-ca-secret
      certificate-openbao-tls:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          name: openbao-tls
        spec:
          secretName: openbao-tls
          commonName: openbao.openbao.svc
          dnsNames:
            - openbao.openbao.svc
            - openbao.openbao.svc.cluster.local
          issuerRef:
            name: openbao-server-ca-issuer
            kind: Issuer
      injector-selfsigned-ca:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          name: injector-selfsigned-ca
        spec:
          isCA: true
          commonName: Agent Inject CA
          secretName: injector-ca-secret
          duration: 87660h  # 10 years
          privateKey:
            algorithm: ECDSA
            size: 256
          issuerRef:
            name: openbao-selfsigned
            kind: Issuer
            group: cert-manager.io
      injector-ca-issuer:
        apiVersion: cert-manager.io/v1
        kind: Issuer
        metadata:
          name: injector-ca-issuer
        spec:
          ca:
            secretName: injector-ca-secret
      injector-certificate:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          name: injector-certificate
        spec:
          secretName: injector-tls
          duration: 24h
          renewBefore: 144m  # roughly 10% of 24h
          dnsNames:
          - openbao-agent-injector-svc
          - openbao-agent-injector-svc.openbao
          - openbao-agent-injector-svc.openbao.svc
          issuerRef:
            name: injector-ca-issuer
          commonName: Agent Inject Cert
      openbao-client-ca-bootstrap:
        apiVersion: cert-manager.io/v1
        kind: Issuer
        metadata:
          name: openbao-client-ca-bootstrap
        spec:
          selfSigned: {}
      openbao-client-ca:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          name: openbao-client-ca
        spec:
          isCA: true
          secretName: openbao-client-ca-secret
          commonName: openbao-client-ca
          privateKey:
            rotationPolicy: Always
            algorithm: RSA
            size: 2048
          issuerRef:
            name: openbao-client-ca-bootstrap
            kind: Issuer
      openbao-client-issuer:
        apiVersion: cert-manager.io/v1
        kind: Issuer
        metadata:
          name: openbao-client-issuer
        spec:
          ca:
            secretName: openbao-client-ca-secret
      app1-client-certificate:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          name: app1-client
        spec:
          secretName: app1-client-cert
          secretTemplate:
            annotations:
              openbao.cert.auth/policy: app1-policy
          commonName: app1-client
          usages:
            - digital signature
            - key encipherment
            - client auth
          privateKey:
            rotationPolicy: Always
            algorithm: RSA
            size: 2048
          issuerRef:
            name: openbao-client-issuer
            kind: Issuer
      openbao-admin-client-certificate:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          name: openbao-admin
        spec:
          secretName: openbao-admin-cert
          secretTemplate:
            annotations:
              openbao.cert.auth/policy: admin-policy
          commonName: openbao-admin
          usages:
            - digital signature
            - key encipherment
            - client auth
          privateKey:
            rotationPolicy: Always
            algorithm: RSA
            size: 2048
          issuerRef:
            name: openbao-client-issuer
            kind: Issuer
      namespace-admin-client-certificate:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          name: namespace-admin
        spec:
          secretName: namespace-admin-client-cert
          secretTemplate:
            annotations:
              openbao.cert.auth/policy: namespace-admin-policy
          commonName: namespace-admin
          usages:
            - digital signature
            - key encipherment
            - client auth
          privateKey:
            rotationPolicy: Always
            algorithm: RSA
            size: 2048
          issuerRef:
            name: openbao-client-issuer
            kind: Issuer
      key-admin-client-certificate:
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          name: key-admin
        spec:
          secretName: key-admin-client-cert
          secretTemplate:
            annotations:
              openbao.cert.auth/policy: key-admin-policy
          commonName: key-admin
          usages:
            - digital signature
            - key encipherment
            - client auth
          privateKey:
            rotationPolicy: Always
            algorithm: RSA
            size: 2048
          issuerRef:
            name: openbao-client-issuer
            kind: Issuer
      openbao-policy-app1:
        apiVersion: v1
        kind: Secret
        metadata:
          name: openbao-policy-app1
        type: Opaque
        stringData:
          app1-policy.hcl: |
            path "kv/data/app1/*" {
              capabilities = ["read", "list"]
            }
      openbao-policy-admin:
        apiVersion: v1
        kind: Secret
        metadata:
          name: openbao-policy-admin
        type: Opaque
        stringData:
          admin-policy.hcl: |
            # Admin policy (explicit paths; refine further later)
            path "auth/token/lookup-self" {
              capabilities = ["read","update"]
            }
            path "auth/token/lookup" {
              capabilities = ["read","update"]
            }
            path "auth/token/renew-self" {
              capabilities = ["read","update"]
            }
            path "auth/token/renew" {
              capabilities = ["read","update"]
            }
            path "auth/token/revoke-self" {
              capabilities = ["read","update"]
            }
            path "sys/policies/acl/*" {
              capabilities = ["create","read","update","delete","list"]
            }
            path "sys/mounts/*" {
              capabilities = ["create","read","update","delete","list","sudo"]
            }
            path "transit/*" {
              capabilities = ["create","read","update","delete","list","sudo"]
            }
            path "secret/*" {
              capabilities = ["create","read","update","delete","list"]
            }
            # JWT auth management
            path "auth/jwt/*" {
              capabilities = ["create","read","update","delete","list","sudo"]
            }
            # Fallback read/list only for everything else
            path "*" {
              capabilities = ["read","list"]
            }
      openbao-policy-namespace-admin:
        apiVersion: v1
        kind: Secret
        metadata:
          name: openbao-policy-namespace-admin
        type: Opaque
        stringData:
          namespace-admin-policy.hcl: |
            # NOTE: Namespace management only works in Enterprise editions. May be ignored in OSS.
            path "sys/namespaces/*" {
              capabilities = ["create","read","update","delete","list"]
            }
            # Allow listing mounts for context
            path "sys/mounts" {
              capabilities = ["read"]
            }
            path "sys/mounts/*" {
              capabilities = ["read","list"]
            }
            # Token self lookup
            path "auth/token/lookup-self" {
              capabilities = ["read"]
            }
            path "auth/token/renew-self" {
              capabilities = ["read","update"]
            }
      openbao-policy-key-admin:
        apiVersion: v1
        kind: Secret
        metadata:
          name: openbao-policy-key-admin
        type: Opaque
        stringData:
          key-admin-policy.hcl: |
            # Manage KV secrets across mounts (v2 common names secret/ and kv/ if present)
            path "secret/*" {
              capabilities = ["create","read","update","delete","list"]
            }
            path "kv/*" {
              capabilities = ["create","read","update","delete","list"]
            }
            # Transit key management
            path "transit/keys/*" {
              capabilities = ["create","read","update","delete","list"]
            }
            path "transit/encrypt/*" {
              capabilities = ["update","read"]
            }
            path "transit/decrypt/*" {
              capabilities = ["update","read"]
            }
            # Token self ops
            path "auth/token/lookup-self" {
              capabilities = ["read"]
            }
            path "auth/token/renew-self" {
              capabilities = ["read","update"]
            }
      openbao-policy-pki-client:
        apiVersion: v1
        kind: Secret
        metadata:
          name: openbao-policy-pki-client
        type: Opaque
        stringData:
          openbao-pki-client.hcl: |
            # Allow signing client certificates via intermediate PKI role (CSR-based)
            path "pki_int/sign/client-cert" {
              capabilities = ["create","update"]
            }
            # Allow signing via root PKI (fallback path)
            path "pki/sign/client-cert" {
              capabilities = ["create","update"]
            }
            # Read CA chains & CRL
            path "pki/cert/ca" {
              capabilities = ["read","list"]
            }
            path "pki_int/cert/ca" {
              capabilities = ["read","list"]
            }
            path "pki_int/cert/crl" {
              capabilities = ["read","list"]
            }
            # Allow token self introspection
            path "auth/token/lookup-self" {
              capabilities = ["read"]
            }
            path "auth/token/renew-self" {
              capabilities = ["read","update"]
            }
            # (Optional) list mounts for debugging
            path "sys/mounts" {
              capabilities = ["read"]
            }
            path "sys/mounts/*" {
              capabilities = ["read","list"]
            }
      openbao-cert-auth-rbac:
        apiVersion: v1
        kind: List
        metadata:
          name: openbao-cert-auth-rbac-bundle
        items:
          - apiVersion: v1
            kind: ServiceAccount
            metadata:
              name: openbao-cert-auth-sync
          - apiVersion: rbac.authorization.k8s.io/v1
            kind: Role
            metadata:
              name: openbao-cert-auth-sync-secrets
            rules:
              - apiGroups: [""]
                resources: ["secrets"]
                verbs: ["get", "list"]
          - apiVersion: rbac.authorization.k8s.io/v1
            kind: RoleBinding
            metadata:
              name: openbao-cert-auth-sync-secrets
            subjects:
              - kind: ServiceAccount
                name: openbao-cert-auth-sync
            roleRef:
              kind: Role
              name: openbao-cert-auth-sync-secrets
              apiGroup: rbac.authorization.k8s.io
          - apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRole
            metadata:
              name: openbao-cert-auth-sync-clusterissuer
            rules:
              - apiGroups: ["cert-manager.io"]
                resources: ["clusterissuers"]
                verbs: ["get","patch","update"]
          - apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRoleBinding
            metadata:
              name: openbao-cert-auth-sync-clusterissuer
            subjects:
              - kind: ServiceAccount
                name: openbao-cert-auth-sync
                namespace: openbao
            roleRef:
              kind: ClusterRole
              name: openbao-cert-auth-sync-clusterissuer
              apiGroup: rbac.authorization.k8s.io
          - apiVersion: rbac.authorization.k8s.io/v1
            kind: ClusterRoleBinding
            metadata:
              name: openbao-cert-auth-sync-auth-delegator
            subjects:
              - kind: ServiceAccount
                name: openbao-cert-auth-sync
                namespace: openbao
            roleRef:
              kind: ClusterRole
              name: system:auth-delegator
              apiGroup: rbac.authorization.k8s.io
      openbao-cert-auth-cronjob:
        apiVersion: batch/v1
        kind: CronJob
        metadata:
          name: openbao-cert-auth-sync
        spec:
          schedule: "*/10 * * * *"
          successfulJobsHistoryLimit: 1
          failedJobsHistoryLimit: 3
          jobTemplate:
            spec:
              template:
                spec:
                  serviceAccountName: openbao-cert-auth-sync
                  restartPolicy: Never
                  volumes:
                    - name: root-token
                      secret:
                        secretName: openbao-root
                    - name: tls
                      secret:
                        secretName: openbao-tls
                    - name: admin-client-cert
                      secret:
                        secretName: openbao-admin-cert
                    - name: serviceaccount-token
                      projected:
                        defaultMode: 0444
                        sources:
                          - serviceAccountToken:
                              path: token
                              expirationSeconds: 3600
                          - configMap:
                              name: kube-root-ca.crt
                              items:
                                - key: ca.crt
                                  path: ca.crt
                  containers:
                    - name: sync
                      image: alpine:3.19
                      volumeMounts:
                        - name: root-token
                          mountPath: /root-token
                          readOnly: true
                        - name: tls
                          mountPath: /tls
                          readOnly: true
                        - name: admin-client-cert
                          mountPath: /admin
                          readOnly: true
                        - name: serviceaccount-token
                          mountPath: /var/run/secrets/kubernetes.io/serviceaccount
                          readOnly: true
                      command: ["sh","-c"]
                      args:
                         - |
                          set -e
                          apk add --no-cache curl jq ca-certificates bash || true
                          # kubectl not in alpine base repos by default; use lightweight client 'kubectl' via curl if absent
                          if ! command -v kubectl >/dev/null 2>&1; then
                            echo "[sync] Installing kubectl (standalone binary)";
                            curl -sL https://dl.k8s.io/release/v1.30.0/bin/linux/amd64/kubectl -o /usr/local/bin/kubectl;
                            chmod +x /usr/local/bin/kubectl;
                          fi
                          command -v kubectl >/dev/null 2>&1 || { echo "[sync] kubectl install failed"; exit 1; }
                          # ------------------------------------------------------------
                          # Install OpenBao CLI (bao) first; fallback to Vault CLI if bao not available
                          # ------------------------------------------------------------
                          if ! command -v bao >/dev/null 2>&1; then
                            echo "[sync] Installing bao CLI";
                            # NOTE: Adjust version or source if OpenBao publishes different artifact paths.
                            BAO_VERSION="1.16.2" # Placeholder aligned with Vault series; change to actual OpenBao release.
                            curl -sL https://github.com/openbao/openbao/releases/download/v${BAO_VERSION}/bao_${BAO_VERSION}_linux_amd64.zip -o /tmp/bao.zip || echo "[sync] Could not download bao (check version/url)";
                            if [ -f /tmp/bao.zip ]; then
                              apk add --no-cache unzip >/dev/null 2>&1 || true
                              unzip -o /tmp/bao.zip -d /usr/local/bin >/dev/null 2>&1 || true
                              chmod +x /usr/local/bin/bao || true
                            fi
                          fi
                          if command -v bao >/dev/null 2>&1; then echo "[sync] bao CLI installed"; else echo "[sync] bao CLI not available (will try vault)"; fi
                          if ! command -v vault >/dev/null 2>&1; then
                            echo "[sync] Installing vault CLI (fallback)";
                            VAULT_VERSION="1.16.2"
                            curl -sL https://releases.hashicorp.com/vault/${VAULT_VERSION}/vault_${VAULT_VERSION}_linux_amd64.zip -o /tmp/vault.zip || { echo "[sync] Failed downloading vault"; }
                            if [ -f /tmp/vault.zip ]; then
                              apk add --no-cache unzip >/dev/null 2>&1 || true
                              unzip -o /tmp/vault.zip -d /usr/local/bin >/dev/null 2>&1 || true
                              chmod +x /usr/local/bin/vault || true
                            fi
                          fi
                          if command -v vault >/dev/null 2>&1; then echo "[sync] vault CLI installed"; fi
                          HOST="https://openbao.openbao.svc:8200"
                          TOKEN=$(cat /root-token/root-token)
                          # Determine CA to trust: prefer /tls/ca.crt if present else /tls/tls.crt (self-signed cert includes its own cert as CA)
                          if [ -f /tls/ca.crt ]; then CA_CERT=/tls/ca.crt; else CA_CERT=/tls/tls.crt; fi
                          CLIENT_CERT=/admin/tls.crt
                          CLIENT_KEY=/admin/tls.key
                          if [ ! -f "$CLIENT_CERT" ] || [ ! -f "$CLIENT_KEY" ]; then echo "[sync] Missing admin client cert/key for mTLS; exiting."; exit 1; fi
                          # Export environment so vault CLI can use mTLS & token automatically.
                          export VAULT_ADDR="$HOST"
                          export VAULT_TOKEN="$TOKEN"
                          # vault CLI does not natively take separate client cert/key env vars; use VAULT_CACERT and set CURL_CA_BUNDLE.
                          export VAULT_CACERT="$CA_CERT"
                          # For mTLS with CLI we wrap via 'vault -ca-cert= -client-cert= -client-key=' flags when needed.
                          VAULT_TLS_ARGS="-ca-cert=$CA_CERT -client-cert=$CLIENT_CERT -client-key=$CLIENT_KEY"
                          # Helper command wrappers preferring bao over vault
                          vault_like() {
                            if command -v bao >/dev/null 2>&1; then
                              bao $VAULT_TLS_ARGS "$@"
                            elif command -v vault >/dev/null 2>&1; then
                              vault $VAULT_TLS_ARGS "$@"
                            else
                              echo "[sync] Neither bao nor vault CLI present; cannot run: $@"; return 1
                            fi
                          }
                          bao_cmd() { vault_like "$@"; }
                          vault_cmd() { vault_like "$@"; }
                          # ---------------------------------------------------------------------------
                          # PKI ROLE NAMING RULES (CN / SAN CONSTRAINTS)
                          # ---------------------------------------------------------------------------
                          # By default we used: {"allow_any_name":true,...} which permits any Common Name.
                          # To enforce naming rules you adjust the role JSON when creating roles:
                          #  * allow_any_name: false -> forces CN/SAN to match allowed_domains list (for DNS-like names)
                          #  * allowed_domains: list of base domains permitted (CN must be a hostname under these if enforce_hostnames=true)
                          #  * allow_subdomains: true to allow sub.example.com if example.com listed
                          #  * allow_glob_domains: true allows patterns like *.svc.cluster.local
                          #  * allowed_uri_sans: restrict URIs (e.g. SPIFFE IDs)
                          #  * allowed_other_sans: constrain arbitrary OIDs (format: "OID:VALUE")
                          #  * require_cn: true ensures CN present in CSR
                          #  * enforce_hostnames: true validates CN is also in SANs (and is a valid hostname)
                          #  * allowed_organizational_units / organization / country / province / locality etc can pin subject attributes.
                          # NOTE: Your current Certificates use CN values like 'app1-client' which are NOT DNS names.
                          # If you switch to restrictive domain-based rules, change CN to something like 'app1.openbao.internal'.
                          # Example STRICT role definition (disabled by default):
                          # ROLE_CONSTRAINTS='{"allow_any_name":false,"allowed_domains":["openbao.internal"],"allow_subdomains":true,"allow_glob_domains":false,"allow_bare_domains":false,"require_cn":true,"enforce_hostnames":false,"key_type":"rsa","key_bits":2048,"max_ttl":"720h","ttl":"24h","generate_lease":true}'
                          # For now we keep permissive role to avoid breaking existing CNs. To activate strict rules:
                          # 1) Uncomment ROLE_CONSTRAINTS above
                          # 2) Replace usage below: -d "$ROLE_CONSTRAINTS" instead of inline JSON
                          # 3) Update Certificate specs to use DNS-acceptable CN or rely solely on SANs.
                          # ---------------------------------------------------------------------------
                          echo "[sync] Waiting for unseal..."
                          until curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s $HOST/v1/sys/seal-status | grep '"sealed":false' >/dev/null; do sleep 3; done
                          echo "[sync] Ensure cert auth enabled..."
                          if ! curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/sys/auth | jq -e 'has("cert/")' >/dev/null 2>&1; then
                          curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/sys/auth/cert -d '{"type":"cert"}'
                          echo "[sync] Enabled cert auth";
                          fi
                          echo "[sync] Ensure jwt auth enabled..."
                          if ! curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/sys/auth | jq -e 'has("jwt/")' >/dev/null 2>&1; then
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/sys/auth/jwt -d '{"type":"jwt"}' && echo "[sync] Enabled jwt auth" || echo "[sync] Failed to enable jwt auth";
                          fi
                          JWT_ISSUER="https://discovery.ingress.garden.gardener.cc-one.showroom.apeirora.eu/projects/kms/shoots/53ec7160-dfe7-47b0-9d96-75daa9c7a687/issuer"
                          echo "[sync] Configuring jwt auth (issuer=$JWT_ISSUER)..."
                          curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/auth/jwt/config -d '{"oidc_discovery_url":"'$JWT_ISSUER'","default_role":"jwt-admin","bound_issuer":"'$JWT_ISSUER'"}' >/dev/null || echo "[sync] jwt config failed (may already exist)"
                          echo "[sync] Ensuring jwt-admin role exists..."
                          if ! curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/auth/jwt/role/jwt-admin | jq -e '.data' >/dev/null 2>&1; then
                            echo "[sync] jwt-admin role not found; creating (role_type=jwt)"
                            # Using role_type=jwt to avoid OIDC redirect requirements since we only validate bearer tokens.
                            RESP=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -w '\n%{http_code}' -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/auth/jwt/role/jwt-admin -d '{"role_type":"jwt","user_claim":"sub","bound_audiences":["vault","openbao","api"],"policies":["admin-policy"],"token_ttl":"1h","token_max_ttl":"2h"}')
                            BODY=$(printf "%s" "$RESP" | sed '$d')
                            CODE=$(printf "%s" "$RESP" | tail -n1)
                            if [ "$CODE" != "200" ] && [ "$CODE" != "204" ]; then
                              echo "[sync] Failed to create jwt-admin role (HTTP $CODE): $BODY"; else echo "[sync] jwt-admin role created"; fi
                          else
                            echo "[sync] jwt-admin role already present"
                          fi
                          echo "[sync] Syncing policy secrets into Vault..."
                          for PSEC in $(kubectl -n openbao get secrets -o json | jq -r '.items[] | select(.metadata.name | startswith("openbao-policy-")) | .metadata.name'); do
                            for KEY in $(kubectl -n openbao get secret "$PSEC" -o json | jq -r '.data | keys[]'); do
                              PNAME=$(echo "$KEY" | sed 's/.hcl$//')
                              PCONTENT=$(kubectl -n openbao get secret "$PSEC" -o json | jq -r --arg k "$KEY" '.data[$k]' | base64 -d)
                              if [ -z "$PCONTENT" ]; then echo "[sync] Empty policy content for $PNAME in $PSEC; skipping"; continue; fi
                              echo "[sync] Upserting policy $PNAME"
                              curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X PUT $HOST/v1/sys/policies/acl/$PNAME -d "{\"policy\":$(printf '%s' "$PCONTENT" | jq -Rs .)}" >/dev/null || echo "[sync] Failed to upsert policy $PNAME"
                            done
                          done
                          echo "[sync] Ensuring transit mount..."
                          if ! curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/sys/mounts | jq -e 'has("transit/")' >/dev/null 2>&1; then
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/sys/mounts/transit -d '{"type":"transit"}' && echo "[sync] Mounted transit" || echo "[sync] Failed to mount transit"
                          fi
                          echo "[sync] Ensuring kubernetes auth enabled..."
                          if ! curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/sys/auth | jq -e 'has("kubernetes/")' >/dev/null 2>&1; then
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/sys/auth/kubernetes -d '{"type":"kubernetes"}' && echo "[sync] Enabled kubernetes auth" || echo "[sync] Failed to enable kubernetes auth"
                          fi
                          echo "[sync] Configuring kubernetes auth..."
                          SA_JWT=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token || true)
                          KUBE_CA=$(cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt || true)
                          if [ -n "$SA_JWT" ] && [ -n "$KUBE_CA" ]; then
                            PAYLOAD=$(jq -n --arg jwt "$SA_JWT" --arg ca "$KUBE_CA" '{token_reviewer_jwt:$jwt, kubernetes_host:"https://kubernetes.default.svc:443", kubernetes_ca_cert:$ca, issuer:"https://kubernetes.default.svc.cluster.local"}')
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/auth/kubernetes/config -d "$PAYLOAD" >/dev/null || echo "[sync] kubernetes auth config failed (may already exist)"
                            echo "[sync] Testing kubernetes login for cert-manager role..."
                            LOGIN_RESP=$(curl --cacert $CA_CERT -s -w '\n%{http_code}' -X POST $HOST/v1/auth/kubernetes/login -d '{"role":"cert-manager-pki","jwt":"'$SA_JWT'"}')
                            LOGIN_BODY=$(printf '%s' "$LOGIN_RESP" | sed '$d')
                            LOGIN_CODE=$(printf '%s' "$LOGIN_RESP" | tail -n1)
                            if [ "$LOGIN_CODE" != "200" ]; then
                              echo "[sync] Kubernetes login test failed (HTTP $LOGIN_CODE)"; echo "$LOGIN_BODY" | jq '.errors? // empty' || true
                            else
                              echo "[sync] Kubernetes login test succeeded"
                            fi
                          else
                            echo "[sync] Missing SA JWT or CA for kubernetes auth config; skipping"
                          fi
                          echo "[sync] Ensuring kubernetes role cert-manager-pki..."
                          if ! curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/auth/kubernetes/role/cert-manager-pki | jq -e '.data' >/dev/null 2>&1; then
                            RESP=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -w '\n%{http_code}' -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/auth/kubernetes/role/cert-manager-pki -d '{"bound_service_account_names":["cert-manager"],"bound_service_account_namespaces":["cert-manager"],"policies":["openbao-pki-client"],"token_ttl":"1h","token_max_ttl":"4h"}')
                            BODY=$(printf "%s" "$RESP" | sed '$d')
                            CODE=$(printf "%s" "$RESP" | tail -n1)
                            if [ "$CODE" != "200" ] && [ "$CODE" != "204" ]; then
                              echo "[sync] Failed to create kubernetes role cert-manager-pki (HTTP $CODE): $BODY"; else echo "[sync] Created kubernetes role cert-manager-pki"; fi
                          else
                            echo "[sync] kubernetes role cert-manager-pki already present"
                          fi
                          echo "[sync] Ensuring PKI mounts..."
                          CURRENT_MOUNTS=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/sys/mounts)
                          if ! echo "$CURRENT_MOUNTS" | jq -e 'has("pki/")' >/dev/null 2>&1; then
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/sys/mounts/pki -d '{"type":"pki","config":{"max_lease_ttl":"87600h"}}' && echo "[sync] Mounted pki" || echo "[sync] Failed to mount pki"
                          fi
                          if ! echo "$CURRENT_MOUNTS" | jq -e 'has("pki_int/")' >/dev/null 2>&1; then
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/sys/mounts/pki_int -d '{"type":"pki","config":{"max_lease_ttl":"43800h"}}' && echo "[sync] Mounted pki_int" || echo "[sync] Failed to mount pki_int"
                          fi
                          echo "[sync] Ensuring root CA generated..."
                          if ! curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/pki/cert/ca | jq -e '.data.certificate' >/dev/null 2>&1; then
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki/root/generate/internal -d '{"common_name":"openbao-root-ca","ttl":"87600h"}' >/dev/null && echo "[sync] Generated root CA" || echo "[sync] Failed to generate root CA"
                            # Configure URLs (best-effort)
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki/config/urls -d '{"issuing_certificates":"'$HOST'/v1/pki/ca","crl_distribution_points":"'$HOST'/v1/pki/crl"}' >/dev/null || true
                          fi
                          echo "[sync] Ensuring intermediate signed..."
                          if ! curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/pki_int/cert/ca | jq -e '.data.certificate' >/dev/null 2>&1; then
                            CSR=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki_int/intermediate/generate/internal -d '{"common_name":"openbao-intermediate","ttl":"43800h"}' | jq -r '.data.csr')
                            if [ -n "$CSR" ]; then
                              CSR_JSON=$(printf '%s' "$CSR" | jq -Rs .)
                              SIGNED=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki/root/sign-intermediate -d '{"csr":'$CSR_JSON',"format":"pem","ttl":"43800h"}' | jq -r '.data.certificate' || true)
                              if [ -n "$SIGNED" ]; then
                                SIGNED_JSON=$(printf '%s' "$SIGNED" | jq -Rs .)
                                curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki_int/intermediate/set-signed -d '{"certificate":'$SIGNED_JSON'}' >/dev/null && echo "[sync] Set signed intermediate" || echo "[sync] Failed to set signed intermediate"
                              else
                                echo "[sync] Failed to sign intermediate CSR"
                              fi
                            else
                              echo "[sync] Failed to generate intermediate CSR"
                            fi
                          fi
                          echo "[sync] Configuring intermediate issuing & default issuer..."
                          # Guard: if ClusterIssuer already points to root PKI path, skip intermediate default issuer attempts to reduce noise
                          CI_PATH=$(kubectl get clusterissuer openbao-pki -o jsonpath='{.spec.vault.path}' 2>/dev/null || true)
                          if [ "$CI_PATH" = "pki/issue/client-cert" ]; then
                            echo "[sync] ClusterIssuer using root PKI path; attempting intermediate recovery"
                            # Try to import issuer if intermediate has cert but no issuers
                            INT_CERT=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/pki_int/cert/ca | jq -r '.data.certificate' || true)
                            if echo "$INT_CERT" | grep -q 'BEGIN CERTIFICATE'; then
                              ISSUERS_JSON=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/pki_int/issuers || true)
                              ISSUER_ID=$(echo "$ISSUERS_JSON" | jq -r '.data.issuers[0].issuer_id // empty' || true)
                              if [ -z "$ISSUER_ID" ]; then
                                echo "[sync] No issuers yet; attempting manual issuer import while on root path"
                                IMPORT_RESP=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -w '\n%{http_code}' -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki_int/issuers/import -d '{"pem_bundle":'"$(printf '%s' "$INT_CERT" | jq -Rs .)"',"set_slices":true,"set_default":true}')
                                IMPORT_BODY=$(printf '%s' "$IMPORT_RESP" | sed '$d')
                                IMPORT_CODE=$(printf '%s' "$IMPORT_RESP" | tail -n1)
                                if [ "$IMPORT_CODE" = "200" ] || [ "$IMPORT_CODE" = "204" ]; then
                                  echo "[sync] Intermediate issuer import succeeded during recovery"
                                  ISSUERS_JSON=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/pki_int/issuers || true)
                                  ISSUER_ID=$(echo "$ISSUERS_JSON" | jq -r '.data.issuers[0].issuer_id // empty' || true)
                                else
                                  echo "[sync] Intermediate issuer import failed (HTTP $IMPORT_CODE): $IMPORT_BODY"
                                fi
                              fi
                              if [ -n "$ISSUER_ID" ]; then
                                echo "[sync] Switching ClusterIssuer back to intermediate path (issuer_id=$ISSUER_ID)"
                                PATCH=$(jq -n '{spec:{vault:{path:"pki_int/issue/client-cert"}}}')
                                kubectl patch clusterissuer openbao-pki --type=merge -p "$PATCH" || echo "[sync] Failed to patch ClusterIssuer back to intermediate"
                              else
                                echo "[sync] Intermediate still lacks issuers; remain on root path"
                              fi
                            else
                              echo "[sync] Intermediate CA certificate not present; cannot recover issuers"
                            fi
                            echo "[sync] Recovery attempt complete"
                          else
                          # Set issuing & CRL URLs for intermediate (optional but avoids missing chain issues)
                          curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki_int/config/urls -d '{"issuing_certificates":"'$HOST'/v1/pki_int/ca","crl_distribution_points":"'$HOST'/v1/pki_int/crl"}' >/dev/null || echo "[sync] Failed to set pki_int URLs"
                          # Ensure there is a default issuer configured (Vault 1.13+ multi-issuer)
                          DEFAULT_STATUS=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -o /dev/null -w '%{http_code}' -H "X-Vault-Token: $TOKEN" $HOST/v1/pki_int/issuers/default || true)
                          if [ "$DEFAULT_STATUS" != "200" ]; then
                            echo "[sync] Default issuer missing; attempting configuration"
                            ISSUERS_JSON=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/pki_int/issuers || true)
                            ISSUER_ID=$(echo "$ISSUERS_JSON" | jq -r '.data.issuers[0].issuer_id // empty' || true)
                            if [ -z "$ISSUER_ID" ]; then
                              echo "[sync] No issuers present; attempting intermediate re-generation (fallback)"
                              # Fallback: regenerate CSR, sign, set-signed again (single retry)
                              CSR=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki_int/intermediate/generate/internal -d '{"common_name":"openbao-intermediate","ttl":"43800h"}' | jq -r '.data.csr')
                              if [ -n "$CSR" ]; then
                                CSR_JSON=$(printf '%s' "$CSR" | jq -Rs .)
                                SIGNED=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki/root/sign-intermediate -d '{"csr":'$CSR_JSON',"format":"pem","ttl":"43800h"}' | jq -r '.data.certificate' || true)
                                if [ -n "$SIGNED" ]; then
                                  SIGNED_JSON=$(printf '%s' "$SIGNED" | jq -Rs .)
                                  curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki_int/intermediate/set-signed -d '{"certificate":'$SIGNED_JSON'}' >/dev/null && echo "[sync] Fallback: set signed intermediate" || echo "[sync] Fallback: failed to set signed intermediate"
                                  # Re-list issuers after fallback
                                  ISSUERS_JSON=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/pki_int/issuers || true)
                                  ISSUER_ID=$(echo "$ISSUERS_JSON" | jq -r '.data.issuers[0].issuer_id // empty' || true)
                                  if [ -z "$ISSUER_ID" ]; then
                                    echo "[sync] Attempting manual issuer import (multi-issuer)"
                                    INT_CERT=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/pki_int/cert/ca | jq -r '.data.certificate' || true)
                                    if echo "$INT_CERT" | grep -q 'BEGIN CERTIFICATE'; then
                                      IMPORT_RESP=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -w '\n%{http_code}' -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki_int/issuers/import -d '{"pem_bundle":'"$(printf '%s' "$INT_CERT" | jq -Rs .)"',"set_slices":true,"set_default":true}')
                                      IMPORT_BODY=$(printf '%s' "$IMPORT_RESP" | sed '$d')
                                      IMPORT_CODE=$(printf '%s' "$IMPORT_RESP" | tail -n1)
                                      if [ "$IMPORT_CODE" = "200" ] || [ "$IMPORT_CODE" = "204" ]; then
                                        echo "[sync] Manual issuer import succeeded"
                                        ISSUERS_JSON=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/pki_int/issuers || true)
                                        ISSUER_ID=$(echo "$ISSUERS_JSON" | jq -r '.data.issuers[0].issuer_id // empty' || true)
                                      else
                                        echo "[sync] Manual issuer import failed (HTTP $IMPORT_CODE): $IMPORT_BODY"
                                      fi
                                    else
                                      echo "[sync] Intermediate certificate PEM not found; issuer import skipped"
                                    fi
                                  fi
                                else
                                  echo "[sync] Fallback: signing intermediate CSR failed"
                                fi
                              else
                                echo "[sync] Fallback: intermediate CSR generation failed"
                              fi
                            fi
                            if [ -n "$ISSUER_ID" ]; then
                              RESP=$(curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -w '\n%{http_code}' -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki_int/issuers/default -d '{"issuer_ref":"'$ISSUER_ID'"}')
                              BODY=$(printf '%s' "$RESP" | sed '$d')
                              CODE=$(printf '%s' "$RESP" | tail -n1)
                              if [ "$CODE" = "200" ] || [ "$CODE" = "204" ]; then
                                echo "[sync] Set default issuer to $ISSUER_ID"
                              else
                                echo "[sync] Failed to set default issuer (HTTP $CODE): $BODY"
                              fi
                            else
                              echo "[sync] No issuers found under pki_int after fallback; switching ClusterIssuer to root PKI path as temporary workaround"
                              # Create root PKI role if absent
                              if ! curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/pki/roles/client-cert | jq -e '.data' >/dev/null 2>&1; then
                                curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki/roles/client-cert -d '{"allow_any_name":true,"key_type":"rsa","key_bits":2048,"max_ttl":"720h","ttl":"24h","generate_lease":true}' >/dev/null && echo "[sync] Created root PKI role client-cert" || echo "[sync] Failed to create root PKI role client-cert"
                              else
                                echo "[sync] Root PKI role client-cert already present"
                              fi
                              # Patch ClusterIssuer path from pki_int to pki (root)
                              CI_CURRENT=$(kubectl get clusterissuer openbao-pki -o jsonpath='{.spec.vault.path}' 2>/dev/null || true)
                              if [ "$CI_CURRENT" != "pki/sign/client-cert" ]; then
                                echo "[sync] Patching ClusterIssuer to use root PKI sign path"
                                PATCH=$(jq -n '{spec:{vault:{path:"pki/sign/client-cert"}}}')
                                kubectl patch clusterissuer openbao-pki --type=merge -p "$PATCH" || echo "[sync] Failed to patch ClusterIssuer path"
                              else
                                echo "[sync] ClusterIssuer already points to root PKI sign path"
                              fi
                              echo "[sync] WARNING: Using root PKI for issuance; intermediate not fully initialized. Investigate why issuers API is empty."
                            fi
                          else
                            echo "[sync] Default issuer already configured for pki_int"
                          fi
                          fi
                          echo "[sync] Ensuring PKI role client-cert..."
                          if ! curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/pki_int/roles/client-cert | jq -e '.data' >/dev/null 2>&1; then
                            curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST $HOST/v1/pki_int/roles/client-cert -d '{"allow_any_name":true,"key_type":"rsa","key_bits":2048,"max_ttl":"720h","ttl":"24h","generate_lease":true}' >/dev/null && echo "[sync] Created PKI role client-cert (permissive)" || echo "[sync] Failed to create PKI role client-cert"
                          else
                            echo "[sync] PKI role client-cert already present"
                          fi
                            echo "[sync] Dynamic caBundle sync (openbao-tls secret tls.crt -> base64)"
                            # Field spec.vault.caBundle expects bytes; we must patch with base64 (raw JSON string containing base64 data)
                            CERT_PEM=$(kubectl -n openbao get secret openbao-tls -o jsonpath='{.data.tls\.crt}' 2>/dev/null | base64 -d || true)
                            if echo "$CERT_PEM" | grep -q "BEGIN CERTIFICATE"; then
                              CA_B64=$(printf '%s' "$CERT_PEM" | base64 -w0)
                            else
                              # Secret may already store base64 of DER; use raw if no PEM markers
                              CA_B64=$(kubectl -n openbao get secret openbao-tls -o jsonpath='{.data.tls\.crt}' 2>/dev/null || true)
                            fi
                            if [ -n "$CA_B64" ]; then
                              CURRENT=$(kubectl get clusterissuer openbao-pki -o jsonpath='{.spec.vault.caBundle}' 2>/dev/null || true)
                              if [ "$CURRENT" != "$CA_B64" ]; then
                                echo "[sync] Patching ClusterIssuer caBundle (base64)"
                                PATCH=$(jq -n --arg cb "$CA_B64" '{spec:{vault:{caBundle:$cb}}}')
                                kubectl patch clusterissuer openbao-pki --type=merge -p "$PATCH" || echo "[sync] Failed to patch caBundle"
                              else
                                echo "[sync] ClusterIssuer caBundle already up to date"
                              fi
                            else
                              echo "[sync] Could not construct base64 caBundle from secret openbao-tls"
                            fi
                          echo "[sync] Processing annotated secrets..."
                          for S in $(kubectl -n openbao get secrets -o json | jq -r '.items[] | select(.metadata.annotations["openbao.cert.auth/policy"]) | .metadata.name'); do
                          POLICY=$(kubectl -n openbao get secret "$S" -o jsonpath='{.metadata.annotations.openbao\.cert\.auth/policy}')
                          echo "[sync] Found annotated secret $S (policies=$POLICY)"
                          CERT_PEM=$(kubectl -n openbao get secret "$S" -o jsonpath='{.data.tls\.crt}' | base64 -d || true)
                          if [ -z "$CERT_PEM" ]; then echo "[sync] Empty certificate data in $S; skipping"; continue; fi
                          echo "[sync] Mapping $S -> $POLICY"
                          PAYLOAD=$(printf '%s' "$CERT_PEM" | jq -Rs --arg policies "$POLICY" '{certificate: ., policies: $policies, ttl: "1h"}')
                          curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" -X POST "$HOST/v1/auth/cert/certs/$S" -d "$PAYLOAD" >/dev/null
                          curl --cacert $CA_CERT --cert $CLIENT_CERT --key $CLIENT_KEY -s -H "X-Vault-Token: $TOKEN" $HOST/v1/auth/cert/certs/$S | jq '.policies' >/dev/null || { echo "[sync] Verification failed for $S"; exit 1; }
                          done
                          echo "[sync] Done."
      openbao-cluster-issuer:
        apiVersion: cert-manager.io/v1
        kind: ClusterIssuer
        metadata:
          name: openbao-pki
          annotations:
            openbao.io/managed: "helm"
        spec:
          vault:
            server: https://openbao.openbao.svc:8200
            # Use sign endpoint to avoid Vault generating its own key (lib vault 'issue' path produces a cert + key mismatch in our mTLS issuance context)
            path: pki_int/sign/client-cert
            auth:
              kubernetes:
                mountPath: /v1/auth/kubernetes
                role: cert-manager-pki
                serviceAccountRef:
                  name: cert-manager
            # caBundle omitted here; CronJob dynamically patches spec.vault.caBundle using base64 of tls.crt from secret openbao-tls.
